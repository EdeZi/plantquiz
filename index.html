<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Plant‚ÄôQuiz ‚Äî Accueil / Normal / R√©vision / P√©dantix</title>
<style>
  :root{--bg:#f7f7f8;--fg:#111;--muted:#666;--brand:#111;--ok:#16a34a;--ko:#ef4444}
  *{box-sizing:border-box} :focus-visible{outline:3px solid #11133b;outline-offset:2px}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  header{position:sticky;top:0;z-index:10;backdrop-filter:saturate(1.5) blur(6px);background:rgba(255,255,255,.7);border-bottom:1px solid #e5e7eb}
  nav{display:flex;gap:12px;align-items:center;max-width:1120px;margin:0 auto;padding:12px 24px}
  .brand{font-size:20px;font-weight:800;cursor:pointer}
  .back{appearance:none;border:1px solid #e5e7eb;background:#fff;border-radius:999px;padding:8px 12px;cursor:pointer}
  .nav-spacer{flex:1}
  .container{max-width:1120px;margin:0 auto;padding:24px}
  .grid{display:grid;gap:14px} .grid3{grid-template-columns:repeat(auto-fit,minmax(260px,1fr))}
  .card{background:#fff;border:1px solid #e5e7eb;border-radius:16px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:20px}
  .btn{appearance:none;border:0;border-radius:999px;padding:10px 16px;background:var(--brand);color:#fff;font-weight:600;cursor:pointer}
  .btn[disabled]{background:#9ca3af;cursor:not-allowed} .btn.outline{background:#fff;color:#111;border:1px solid #e5e7eb}
  .muted{color:var(--muted)}
  .choices{display:grid;gap:10px;margin-top:12px}
  .choice{padding:14px 16px;border:1px solid #e5e7eb;border-radius:14px;text-align:left;background:#fff;color:#111;cursor:pointer;transition:box-shadow .2s,border-color .2s,background .2s}
  .choice:hover{box-shadow:0 2px 12px rgba(0,0,0,.06)}
  .choice.selected{border-color:var(--brand);box-shadow:0 0 0 3px rgba(17,17,17,.08);background:rgba(17,17,17,.02)}
  .answer.ok{border-color:var(--ok);box-shadow:0 0 0 3px rgba(22,163,74,.2)}
  .answer.ko{border-color:var(--ko);box-shadow:0 0 0 3px rgba(239,68,68,.2)}
  .row{display:flex;gap:8px;justify-content:flex-end;margin-top:16px}
  .rowL{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .field{display:grid;gap:6px}
  select, input[type="text"]{padding:10px 12px;border:1px solid #e5e7eb;border-radius:10px}
  .group{border:1px solid #e5e7eb;border-radius:12px;padding:12px;margin-top:8px}
  .pill{padding:4px 10px;border:1px solid #e5e7eb;border-radius:999px;background:#fff;font-size:12px}
  #prof .fields{display:grid;gap:12px;margin-top:16px}
  #prof textarea{min-height:96px;resize:vertical}
  #profChoices{display:grid;gap:8px}
  #profChoices label{display:flex;gap:8px;align-items:center}
  #profChoices input[type="text"]{flex:1}
  #profOutput{min-height:140px;font-family:"SFMono-Regular",Consolas,"Liberation Mono",Menlo,monospace}
  #historyPanel{position:fixed;inset:0;background:rgba(17,17,17,.45);display:flex;align-items:center;justify-content:center;z-index:60}
  #historyPanel[hidden]{display:none}
  #historyPanel .history-card{max-width:520px;width:min(92%,520px);max-height:80vh;overflow:auto}
  #historyList{display:grid;gap:12px;margin-top:12px}
  .history-item{border:1px solid #e5e7eb;border-radius:12px;padding:12px;background:#fff;box-shadow:0 1px 2px rgba(0,0,0,.04)}
  .history-item.ok{border-color:rgba(22,163,74,.4)}
  .history-item.ko{border-color:rgba(239,68,68,.4)}
  .history-meta{display:flex;gap:8px;align-items:center;font-size:13px;margin-bottom:6px}
  .history-result.ok{color:var(--ok)}
  .history-result.ko{color:var(--ko)}
  #historyPanel h3{margin:0}
  /* P√©dantix */
  .pedantix-text{line-height:1.7; font-size:1.05rem}
  .mask{background:#111;color:#111;border-radius:4px;padding:1px 4px;cursor:pointer;user-select:none;transition:background .2s,color .2s}
  .mask:focus-visible{outline:2px solid #4b5563;outline-offset:2px}
  .mask-show{background:#e0e7ff;color:#111;font-weight:600}
  .token{display:inline}
  .pillScore{display:inline-block;margin-left:8px;padding:2px 8px;border-radius:999px;border:1px solid #e5e7eb;background:#fff;font-size:12px}
  .exp{margin-top:10px;padding:12px;border:1px dashed #e5e7eb;border-radius:12px;background:#fafafa}
</style>
</head>
<body>
<header>
  <nav>
    <button id="backBtn" class="back" hidden>‚Üê Retour</button>
    <div id="brand" class="brand">üåø Plant‚ÄôQuiz</div>
    <span class="nav-spacer"></span>
    <button id="profBtn" class="btn outline" type="button" data-go="prof">Outil prof</button>
  </nav>
</header>

<main class="container">
  <section id="prof" hidden>
    <div class="card">
      <h2 style="margin:0">Outil prof ‚Äî G√©n√©rateur de questions</h2>
      <p class="muted" style="margin:6px 0 0">Pr√©parez des questions hors-ligne √† copier dans vos fichiers. Utilisez le bouton ¬´‚ÄØRetour‚ÄØ¬ª en haut de page pour revenir √† l‚Äôaccueil.</p>
      <div class="fields">
        <label class="field">
          <span class="muted">Mati√®re / UE</span>
          <select id="profMatter"></select>
        </label>
        <label class="field">
          <span class="muted">√ânonc√©</span>
          <textarea id="profPrompt" placeholder="Saisir la question" spellcheck="false"></textarea>
        </label>
        <div class="field">
          <span class="muted">R√©ponses possibles</span>
          <div id="profChoices"></div>
          <div class="rowL" style="justify-content:flex-start;margin-top:6px">
            <button id="profChoiceAdd" class="btn outline" type="button">+ Ajouter une option</button>
            <button id="profChoiceRemove" class="btn outline" type="button">‚àí Retirer la derni√®re option</button>
          </div>
        </div>
        <label class="field">
          <span class="muted">Explication (facultative)</span>
          <textarea id="profExplain" placeholder="Ajoutez un compl√©ment ou laissez vide" spellcheck="false"></textarea>
        </label>
        <div class="row" style="justify-content:flex-start">
          <button id="profAdd" class="btn" type="button">Ajouter</button>
          <button id="profReset" class="btn outline" type="button">R√©initialiser</button>
        </div>
        <label class="field">
          <span class="muted">Sortie JSON (une ligne par question)</span>
          <textarea id="profOutput" readonly spellcheck="false"></textarea>
        </label>
      </div>
    </div>
  </section>
  <!-- ACCUEIL -->
  <section id="home">
    <div class="grid grid3">
      <div class="card">
        <h3>Quiz normal</h3>
        <p class="muted">Plus tu r√©ponds juste, plus ton Elo monte et la difficult√© augmente.</p>
        <div class="row"><button data-go="normal" class="btn">Commencer</button></div>
      </div>
      <div class="card">
        <h3>Quiz r√©vision (par semestre)</h3>
        <p class="muted">Choisis S5 √† S9, coche des UE et r√©vise avec un quiz cibl√©.</p>
        <div class="row"><button data-go="revision" class="btn">S√©lectionner des UE</button></div>
      </div>
      <div class="card">
        <h3>P√©dantix v√©g√©tal (du jour)</h3>
        <p class="muted">Texte √† trous : tape des mots pour d√©voiler et devine le titre cach√©.</p>
        <div class="row"><button data-go="pedantix" class="btn">Jouer</button></div>
      </div>
    </div>
    <p class="muted" style="text-align:center;margin-top:22px">Donn√©es dans <code>/data/</code> : <code>questions_normal.json</code>, <code>pedantix_daily.json</code>.</p>
  </section>

  <!-- NORMAL -->
  <section id="normal" hidden>
    <div class="card">
      <h2 id="quizTitle" style="margin:0 0 6px">Quiz normal</h2>
      <p id="quizSubtitle" class="muted">Plus tu r√©ponds juste, plus ton Elo monte et la difficult√© augmente.</p>
      <hr style="margin:12px 0"/>
      <article>
        <div class="rowL" style="justify-content:flex-start;gap:8px;margin-bottom:6px">
          <span id="eloWrap" class="pill">Elo: <b id="eloPill2">0</b></span>
          <button id="setEloBtn" class="btn outline" title="R√©gler manuellement ton Elo">‚ÜïÔ∏è R√©gler Elo</button>
          <span class="pill">Q: <b id="qPill2">0</b></span>
          <span class="pill">Bonnes: <b id="goodPill2">0</b></span>
          <span id="streakWrap" class="pill">Streak: <b id="streakPill2">0</b> <span id="streakNote2" class="muted"></span></span>
          <button id="historyBtn" class="btn outline" type="button" hidden style="margin-left:auto">Historique</button>
        </div>
        <h3 id="qPrompt"></h3>
        <div class="choices" id="choices"></div>
        <div id="explain" class="exp" hidden></div>
        <div class="row" style="justify-content:flex-end;flex-wrap:wrap;gap:10px">
          <button id="checkBtn" class="btn" type="button" disabled hidden>Valider la s√©lection</button>
          <button id="nextBtn" class="btn" disabled>Question suivante</button>
        </div>
      </article>
    </div>
  </section>

  <!-- R√âVISION -->
  <section id="revision" hidden>
    <div class="card">
      <h2 style="margin:0 0 8px">R√©vision ‚Äî Choix des UE</h2>
      <div class="rowL">
        <label class="field" style="min-width:220px">
          <span class="muted">Semestre</span>
          <select id="selSem">
            <option value="S5">S5</option>
            <option value="S6">S6</option>
            <option value="S7">S7</option>
            <option value="S8">S8</option>
            <option value="S9">S9</option>
          </select>
        </label>
      </div>
      <div class="row" style="gap:8px;margin:10px 0">
        <button id="btnAllCore" class="btn outline">Tout Tronc commun</button>
        <button id="btnAllOpt" class="btn outline">Tout Options</button>
        <button id="btnClear" class="btn outline">Tout d√©cocher</button>
      </div>
      <div class="group"><b>Tronc commun</b><div id="ueCore"></div></div>
      <div class="group"><b>Options</b><div id="ueOpt"></div></div>
      <div class="row" style="justify-content:flex-start">
        <button id="revLaunch" class="btn" disabled>Lancer</button>
      </div>
    </div>
  </section>

  <!-- P√âDANTIX DAILY -->
  <section id="pedantix" hidden>
    <div class="card">
      <div class="rowL" style="justify-content:space-between">
        <h2 style="margin:0">P√©dantix du jour <span id="pedScore" class="pillScore" hidden></span></h2>
        <div class="rowL">
          <button id="pedInfo" class="btn outline" type="button" aria-expanded="false" aria-controls="pedInfoPanel" title="Afficher les r√®gles">‚ÑπÔ∏è Info</button>
          <button id="pedReset" class="btn outline">R√©initialiser du jour</button>
        </div>
      </div>
      <p class="muted" id="pedTitleMask"></p>
      <div id="pedInfoPanel" class="exp ped-desc" hidden>
        <p><strong>Objectif :</strong> taper des mots pour d√©voiler progressivement l‚Äôintroduction et deviner le titre cach√©.</p>
        <p>Les mots trouv√©s deviennent lisibles, les autres restent masqu√©s. Clique ou maintiens sur une bo√Æte noire pour conna√Ætre la longueur d‚Äôun mot.</p>
      </div>
      <div id="pedText" class="pedantix-text"></div>
      <div class="row" style="justify-content:flex-start;margin-top:12px">
        <input id="pedInput" class="choice" placeholder="Tape un mot (objectif : le titre cach√©)" />
      </div>
      <ol id="pedGuesses" class="results"></ol>
    </div>
  </section>
</main>

<section id="historyPanel" hidden>
  <div class="card history-card">
    <div class="rowL" style="justify-content:space-between;align-items:center">
      <h3>Historique des questions</h3>
      <button id="historyClose" class="btn outline" type="button">Fermer</button>
    </div>
    <p id="historyEmpty" class="muted" style="margin:12px 0 0">Aucune question r√©pondue pour l‚Äôinstant.</p>
    <div id="historyList"></div>
  </div>
</section>

<script>
/* ========= Helpers & √©tat commun ========= */
const $ = function(id){ return document.getElementById(id); };
/* Polyfills pour navigateurs anciens */
if(typeof Array.prototype.find !== "function"){
  Array.prototype.find = function(predicate, thisArg){
    if(this == null) throw new TypeError("Array.prototype.find appel√© sur null ou undefined");
    if(typeof predicate !== "function") throw new TypeError("predicate doit √™tre une fonction");
    var list = Object(this);
    var len = list.length >>> 0;
    for(var i=0;i<len;i++){
      var value = list[i];
      if(predicate.call(thisArg, value, i, list)) return value;
    }
    return undefined;
  };
}
if(typeof Array.prototype.findIndex !== "function"){
  Array.prototype.findIndex = function(predicate, thisArg){
    if(this == null) throw new TypeError("Array.prototype.findIndex appel√© sur null ou undefined");
    if(typeof predicate !== "function") throw new TypeError("predicate doit √™tre une fonction");
    var list = Object(this);
    var len = list.length >>> 0;
    for(var i=0;i<len;i++){
      if(predicate.call(thisArg, list[i], i, list)) return i;
    }
    return -1;
  };
}
if(typeof Array.prototype.includes !== "function"){
  Array.prototype.includes = function(searchElement, fromIndex){
    if(this == null) throw new TypeError("Array.prototype.includes appel√© sur null ou undefined");
    var list = Object(this);
    var len = list.length >>> 0;
    if(!len) return false;
    var start = fromIndex | 0;
    var k = start < 0 ? Math.max(len + start, 0) : start;
    while(k < len){
      if(list[k] === searchElement || (searchElement !== searchElement && list[k] !== list[k])) return true;
      k++;
    }
    return false;
  };
}
if(typeof window !== "undefined" && window.NodeList && !window.NodeList.prototype.forEach){
  window.NodeList.prototype.forEach = Array.prototype.forEach;
}
/* Compat accents: remplace \\p{Diacritic} par la plage U+0300‚Äì036F pour large support */
function strip(s){
  var val = s || '';
  if(val.normalize){
    try{
      val = val.normalize("NFD");
    }catch(e){}
  }
  return val.replace(/[\u0300-\u036f]/g,'').toLowerCase();
}

/* ========= Navigation ========= */
function go(mode){
  ["home","normal","revision","pedantix","prof"].forEach(id=>$(id).hidden=true);
  $(mode).hidden=false;
  $("backBtn").hidden = (mode==="home");
  try{ history.replaceState({}, "", mode==="home" ? location.pathname : `?mode=${mode}`); }catch{}
  if(mode!=="normal"){ const panel=$("historyPanel"); if(panel) panel.hidden=true; }
}
$("brand").onclick=()=>go("home");
$("backBtn").onclick=()=>go("home");

/* ========= Chargement data ========= */
function uniqList(list){
  const seen=new Set();
  const out=[];
  list.forEach(item=>{
    if(!item) return;
    if(seen.has(item)) return;
    seen.add(item);
    out.push(item);
  });
  return out;
}

function candidateUrls(file){
  const trimmed = String(file||"").replace(/^\.\//,"");
  const guesses=[file, `./${trimmed}`, trimmed];
  if(trimmed.startsWith("data/")){
    guesses.push(`../${trimmed}`);
    guesses.push(`/${trimmed}`);
  }
  const bases=[];
  if(typeof document!=="undefined" && document.baseURI){ bases.push(document.baseURI); }
  if(typeof location!=="undefined"){
    if(location.href) bases.push(location.href);
    const locOrigin = (typeof location.origin==="string" && location.origin!=="null") ? location.origin : "";
    if(locOrigin){
      bases.push(locOrigin + (locOrigin.endsWith("/")?"":"/"));
    }
    if(location.pathname){
      const pathParts=location.pathname.split("/").filter(Boolean);
      while(pathParts.length){
        if(locOrigin){
          bases.push(locOrigin + "/" + pathParts.join("/") + "/");
        }
        pathParts.pop();
      }
    }
  }
  bases.forEach(base=>{
    try{ guesses.push(new URL(trimmed, base).href); }catch{}
  });
  return uniqList(guesses);
}

function xhrJSON(url){
  return new Promise(resolve=>{
    if(typeof XMLHttpRequest!=="function"){ resolve(null); return; }
    try{
      const xhr=new XMLHttpRequest();
      xhr.open("GET", url, true);
      xhr.responseType="json";
      xhr.onload=()=>{
        if(xhr.status>=200 && xhr.status<300 || xhr.status===0){
          if(xhr.response!==null) resolve(xhr.response);
          else{
            try{ resolve(JSON.parse(xhr.responseText)); }
            catch{ resolve(null); }
          }
        }else{
          resolve(null);
        }
      };
      xhr.onerror=xhr.onabort=()=>resolve(null);
      xhr.send();
    }catch{ resolve(null); }
  });
}

async function fetchJSON(url){
  if(typeof fetch==="function"){
    try{
      const response=await fetch(url,{cache:"no-store"});
      if(response && response.ok){
        return await response.json();
      }
    }catch{}
  }
  return await xhrJSON(url);
}

async function loadJSON(file){
  const urls=candidateUrls(file);
  for(const url of urls){
    const data=await fetchJSON(url);
    if(data!==null && data!==undefined){
      return data;
    }
  }
  return null;
}
const todayISO = (()=>{ const d=new Date(); const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const dd=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${dd}`; })();
const DEMO_QUESTIONS=[{id:"demo1",level:1,prompt:"Quelle partie r√©alise la photosynth√®se ?",choices:[{id:"a",text:"Racines"},{id:"b",text:"Feuilles",correct:true},{id:"c",text:"Fleurs"},{id:"d",text:"Graines"}],explanation:"Les feuilles contiennent des chloroplastes."}];

let loaded=false;
/* IMPORTANT: on distingue les questions normales originales de la liste active. */
let QUESTIONS_NORMAL=[], QUESTIONS=[], PED_DAILY=null;
let REV_DATA={semesters:[]};
let activeQuizMode="normal";
let revisionHistory=[];
let normalDataFallback=false;
let normalDataError="";

function cloneQuestionList(list){
  if(!Array.isArray(list)) return [];
  return list.map((item, idx)=>{
    if(!item || typeof item!=="object"){
      return {
        id: `normal_${idx}`,
        level: 1,
        prompt: "Question",
        choices: [],
        explanation: "",
      };
    }
    const levelValue = Number(item.level);
    const safeLevel = Number.isFinite(levelValue) ? Math.max(LEVEL_MIN, levelValue) : LEVEL_MIN;
    const clonedChoices = Array.isArray(item.choices)
      ? item.choices.map(choice=>choice && typeof choice==="object" ? ({...choice}) : {text:String(choice==null?"":choice)})
      : [];
    return {
      ...item,
      id: item.id || `normal_${idx}`,
      level: safeLevel,
      prompt: item.prompt || "Question",
      choices: clonedChoices,
      explanation: item.explanation || "",
    };
  });
}

function sanitizeNormalQuestions(payload){
  if(payload && typeof payload==="object" && !Array.isArray(payload) && Array.isArray(payload.questions)){
    return cloneQuestionList(payload.questions);
  }
  if(Array.isArray(payload)){
    return cloneQuestionList(payload);
  }
  return [];
}

async function loadData(){
  if(loaded) return;
  const normalRaw = await loadJSON("data/questions_normal.json");
  const sanitizedNormal = sanitizeNormalQuestions(normalRaw);
  normalDataFallback = !sanitizedNormal.length;
  normalDataError = normalDataFallback && normalRaw===null ? "Impossible de charger data/questions_normal.json. V√©rifie le chemin ou h√©berge le dossier via un serveur web." : "";
  if(normalDataFallback){
    console.warn("Impossible de charger data/questions_normal.json, utilisation du jeu de d√©mo.");
  }
  QUESTIONS_NORMAL = normalDataFallback ? cloneQuestionList(DEMO_QUESTIONS) : sanitizedNormal;
  QUESTIONS = [...QUESTIONS_NORMAL];
  const daily = await loadJSON("data/pedantix_daily.json") || [{date:todayISO,target:"Chloroplaste",text:DEMO_QUESTIONS[0].explanation||"Texte."}];
  PED_DAILY = (Array.isArray(daily) ? daily.find(x=>x.date===todayISO) : null) || (Array.isArray(daily)?daily[0]:null) || {date:todayISO,target:"Chloroplaste",text:"Texte d√©mo."};
  const rev = await loadJSON("data/questions_revision.json");
  REV_DATA = (rev && Array.isArray(rev.semesters)) ? rev : {semesters:[]};
  fillProfMatter();
  loaded=true;
}

function resetRevisionHistory(){
  revisionHistory.length=0;
  const panel=$("historyPanel");
  if(panel) panel.hidden=true;
  const list=$("historyList");
  if(list) list.innerHTML="";
  const empty=$("historyEmpty");
  if(empty) empty.hidden=false;
}

function updateHistoryUI(){
  const list=$("historyList");
  const empty=$("historyEmpty");
  if(!list || !empty) return;
  if(!revisionHistory.length){
    list.innerHTML="";
    empty.hidden=false;
    return;
  }
  empty.hidden=true;
  list.innerHTML="";
  const frag=document.createDocumentFragment();
  revisionHistory.forEach((item, idx)=>{
    const block=document.createElement("div");
    block.className="history-item" + (item.win?" ok":" ko");
    const meta=document.createElement("div");
    meta.className="history-meta";
    const badge=document.createElement("span");
    badge.className="pill";
    badge.textContent=`Q${idx+1}`;
    meta.appendChild(badge);
    const result=document.createElement("span");
    result.className="history-result " + (item.win?"ok":"ko");
    result.textContent = item.win ? "‚úÖ Bonne r√©ponse" : "‚ùå Mauvaise r√©ponse";
    meta.appendChild(result);
    block.appendChild(meta);
    const title=document.createElement("h4");
    title.textContent=item.prompt || "Question";
    block.appendChild(title);
    const user=document.createElement("p");
    const userLabel=document.createElement("strong");
    userLabel.textContent="Ta r√©ponse : ";
    user.appendChild(userLabel);
    user.appendChild(document.createTextNode(item.picked || "‚Äî"));
    block.appendChild(user);
    const correct=document.createElement("p");
    const correctLabel=document.createElement("strong");
    correctLabel.textContent="Bonne r√©ponse : ";
    correct.appendChild(correctLabel);
    correct.appendChild(document.createTextNode(item.correct || "‚Äî"));
    block.appendChild(correct);
    if(item.explanation){
      const expl=document.createElement("p");
      expl.className="muted";
      expl.textContent=item.explanation;
      block.appendChild(expl);
    }
    frag.appendChild(block);
  });
  list.appendChild(frag);
}

function restoreNormalQuestions(){
  QUESTIONS = [...QUESTIONS_NORMAL];
  activeQuizMode="normal";
  prepareLevelBuckets(QUESTIONS_NORMAL);
  resetRevisionHistory();
  resetQuizState();
}

/* ========= MODE NORMAL ‚Äî Elo ========= */
const MAX_LEVEL=12;
const LEVEL_MIN=1;
const MIN_RATING=0;
const LEVEL_STEP=100;
const levelToRating = l => {
  const clamped = Math.min(MAX_LEVEL, Math.max(LEVEL_MIN, l));
  return MIN_RATING + (clamped - 1) * LEVEL_STEP;
};
const MAX_RATING = levelToRating(MAX_LEVEL);
const eloToLevelFloat = e => ((Math.max(MIN_RATING, e) - MIN_RATING) / LEVEL_STEP) + 1;
const clampLevel = l => Math.min(MAX_LEVEL, Math.max(LEVEL_MIN, l));
const eloToLevel    = e => clampLevel(Math.round(eloToLevelFloat(e)));

let elo=MIN_RATING, level=eloToLevel(elo);
let levelAnchor=eloToLevelFloat(elo);
let qCount=0, goodCount=0, streak=0, wrongStreak=0, answeredTotal=0;

const BASE_K=22, CALIB_K=32;
const STREAK_STEP=0.05, STREAK_MAX=1.2, WRONG_STEP=0.05, WRONG_MAX=0.15;
function expected(eloA, eloB){ return 1/(1+Math.pow(10,(eloB-eloA)/400)); }
function kFactor(){
  const base = (answeredTotal<CALIBRATION_LENGTH) ? CALIB_K : BASE_K;
  const streakMult = 1 + Math.min(STREAK_MAX-1, Math.max(0, streak*STREAK_STEP));
  const wrongMult = 1 - Math.min(WRONG_MAX, Math.max(0, wrongStreak*WRONG_STEP));
  return Math.round(base * streakMult * wrongMult);
}
function blendAnchor(nextLevel){
  levelAnchor = (0.75*levelAnchor) + (0.25*nextLevel);
  levelAnchor = clampLevel(levelAnchor);
  level = eloToLevel(levelToRating(levelAnchor));
}
function applyElo(win, qLevel){
  const rq = levelToRating(qLevel);
  const ex = expected(elo, rq);
  const K = kFactor();
  elo = Math.round(elo + K * ((win?1:0) - ex));
  if(!Number.isFinite(elo)) elo = MIN_RATING;
  if(elo < MIN_RATING) elo = MIN_RATING;
  const instantLevel = clampLevel(eloToLevelFloat(elo));
  blendAnchor(instantLevel);
}

const recentIds=[]; const RECENT_MAX=40;
const errorQueue=[];
const ERROR_REASK_DELAY=2;
const CALIBRATION_SEQUENCE=[4,6,3,7,5,8];
const CALIBRATION_LENGTH=CALIBRATION_SEQUENCE.length;

const STATS_KEY="plantquiz.stats.v2";
const questionStats=new Map();
let statsSaveTimer=null;

function remember(id){
  if(!id) return;
  recentIds.push(id);
  if(recentIds.length>RECENT_MAX) recentIds.shift();
}
function forgetRecent(id){
  const idx = recentIds.indexOf(id);
  if(idx>=0) recentIds.splice(idx,1);
}
function notRecentlyAsked(q){ return !recentIds.includes(q.id); }

function loadQuestionStats(){
  if(typeof localStorage==="undefined") return;
  try{
    const raw=localStorage.getItem(STATS_KEY);
    if(!raw) return;
    const parsed=JSON.parse(raw);
    if(parsed && typeof parsed==="object"){
      Object.keys(parsed).forEach(id=>{
        const entry=parsed[id];
        if(entry && typeof entry==="object") questionStats.set(id,{...entry});
      });
    }
  }catch{}
}
function saveQuestionStats(){
  if(typeof localStorage==="undefined") return;
  try{
    const payload={};
    questionStats.forEach((val,id)=>{ payload[id]=val; });
    localStorage.setItem(STATS_KEY, JSON.stringify(payload));
  }catch{}
}
function scheduleStatsSave(){
  if(statsSaveTimer) return;
  statsSaveTimer=setTimeout(()=>{ statsSaveTimer=null; saveQuestionStats(); }, 600);
}
loadQuestionStats();
if(typeof window!=="undefined"){
  window.addEventListener("beforeunload", saveQuestionStats);
  window.addEventListener("pagehide", saveQuestionStats);
}

function questionStatFor(id, baseLevel){
  if(!id) return null;
  if(!questionStats.has(id)){
    questionStats.set(id,{
      seen:0,
      correct:0,
      rating:levelToRating(baseLevel||LEVEL_MIN),
      lastSeen:0,
      lastWrong:-1,
    });
  }
  const higher = availableLevels.find(lvl=>lvl>target);
  if(higher==null) return lower;
  return Math.abs(target-higher) < Math.abs(target-lower) ? higher : lower;
}

function levelFromElo(value){
  const raw = Math.floor(Math.max(0, value) / ELO_PER_LEVEL) + 1;
  return clampToAvailableLevel(raw);
}

function currentGain(){
  const boostActive = answeredTotal < EARLY_BOOST_LIMIT;
  return BASE_GAIN * (boostActive ? EARLY_MULTIPLIER : 1);
}

function applyProgress(win){
  const gain = currentGain();
  if(win){
    elo += gain;
  }else{
    elo = Math.max(ELO_START, elo - LOSS_PENALTY);
  }
  answeredTotal++;
  level = levelFromElo(elo);
}

function remember(id){
  if(!id) return;
  recentIds.push(id);
  if(recentIds.length>RECENT_MAX) recentIds.shift();
}

function notRecentlyAsked(q){
  if(!q) return false;
  if(!q.id) return true;
  return !recentIds.includes(q.id);
}

function orderLevelsByProximity(target){
  const sorted = [...availableLevels];
  sorted.sort((a,b)=>{
    const da=Math.abs(a-target);
    const db=Math.abs(b-target);
    if(da===db) return a-b;
    return da-db;
  });
  return sorted;
}

function pickFromLevels(list){
  for(const lvl of list){
    const bucket = levelBuckets.get(lvl) || [];
    const fresh = bucket.filter(notRecentlyAsked);
    if(fresh.length) return fresh[Math.floor(Math.random()*fresh.length)];
  }
  for(const lvl of list){
    const bucket = levelBuckets.get(lvl) || [];
    if(bucket.length) return bucket[Math.floor(Math.random()*bucket.length)];
  }
  return null;
}

function pickNormalQuestion(){
  if(!availableLevels.length) return null;
  const desired = levelFromElo(elo);
  const levelOrder = orderLevelsByProximity(desired);
  if(!levelOrder.includes(desired)) levelOrder.unshift(desired);
  const unique=[];
  levelOrder.forEach(lvl=>{ if(!unique.includes(lvl)) unique.push(lvl); });
  return pickFromLevels(unique);
}

function filteredChoicesForLevel(choices){
  if(!Array.isArray(choices)) return [];
  const clone = choices.map(choice=>choice && typeof choice==="object" ? ({...choice}) : {text:String(choice||"")});
  return clone.sort(()=>Math.random()-0.5);
}

function pickQuestion(){
  if(!QUESTIONS || !QUESTIONS.length) return null;
  if(activeQuizMode==="normal"){
    return pickNormalQuestion();
  }
  const pool = QUESTIONS.filter(notRecentlyAsked);
  if(pool.length) return pool[Math.floor(Math.random()*pool.length)];
  return QUESTIONS[Math.floor(Math.random()*QUESTIONS.length)];
}

let currentQ=null, locked=false;
let multiSelect=false;
const selectedChoiceIds=new Set();
let choiceButtons=[];
let choiceById=new Map();
function updateMeta(){
  const quizTitle=$("quizTitle"), quizSubtitle=$("quizSubtitle");
  if(quizTitle){
    quizTitle.textContent = activeQuizMode==="revision" ? "Quiz r√©vision" : "Quiz normal";
  }
  if(quizSubtitle){
    quizSubtitle.textContent = activeQuizMode==="revision"
      ? "R√©vise les UE s√©lectionn√©es sans Elo ni difficult√© adaptative."
      : normalDataError
        ? `‚ö†Ô∏è ${normalDataError}`
        : normalDataFallback
          ? "‚ö†Ô∏è Jeu de d√©mo : v√©rifie data/questions_normal.json pour charger toutes les questions."
          : "Plus tu r√©ponds juste, plus ton Elo monte et la difficult√© augmente.";
  }
  $("eloPill2").textContent = activeQuizMode==="normal" ? `${elo} ¬∑ niv. ${level}` : "‚Äî";
  $("qPill2").textContent=qCount;
  $("goodPill2").textContent=goodCount;
  $("streakPill2").textContent=streak;
  const streakLabel = (streak>=7?"ü•µ bouillant":streak>=4?"üî• en feu":streak>=2?"üòé √ßa progresse":streak===1?"üôÇ bien jou√©":streak===0?"":"üßä va r√©viser");
  const boostLabel = (activeQuizMode==="normal" && answeredTotal < EARLY_BOOST_LIMIT) ? "‚ö° boost x2" : "";
  const noteParts=[streakLabel, boostLabel].filter(Boolean);
  $("streakNote2").textContent = noteParts.join(" ¬∑ ");
  const showElo = activeQuizMode==="normal";
  const eloWrap=$("eloWrap"), streakWrap=$("streakWrap"), setEloBtn=$("setEloBtn"), historyBtn=$("historyBtn");
  if(eloWrap) eloWrap.hidden=!showElo;
  if(streakWrap) streakWrap.hidden=!showElo;
  if(setEloBtn) setEloBtn.hidden=!showElo;
  if(historyBtn) historyBtn.hidden=showElo;
}
function clearChoiceSelection(){
  choiceButtons.forEach(btn=>btn.classList.remove("selected"));
  selectedChoiceIds.clear();
}
function updateCheckButton(){
  const checkBtn=$("checkBtn");
  if(!checkBtn) return;
  if(multiSelect){
    checkBtn.hidden=false;
    checkBtn.disabled = locked || selectedChoiceIds.size===0;
  }else{
    checkBtn.hidden=true;
    checkBtn.disabled=true;
  }
}
function handleChoiceClick(choiceId, btn){
  if(locked) return;
  if(multiSelect){
    const key=String(choiceId);
    if(selectedChoiceIds.has(key)){
      selectedChoiceIds.delete(key);
      btn.classList.remove("selected");
    }else{
      selectedChoiceIds.add(key);
      btn.classList.add("selected");
    }
    updateCheckButton();
  }else{
    clearChoiceSelection();
    selectedChoiceIds.add(String(choiceId));
    choiceButtons.forEach(b=>{
      if(b===btn) b.classList.add("selected");
      else b.classList.remove("selected");
    });
    evaluateAnswer(new Set(selectedChoiceIds));
  }
}
function evaluateAnswer(selectedIds){
  if(locked) return;
  locked=true;
  const checkBtn=$("checkBtn");
  if(checkBtn) checkBtn.disabled=true;
  const normalizedSelected=new Set();
  if(selectedIds && typeof selectedIds.forEach==="function"){
    selectedIds.forEach(id=>{
      if(id===undefined || id===null) return;
      normalizedSelected.add(String(id));
    });
  }
  const correctEntries=[...choiceById.entries()].filter(([,choice])=>choice && choice.correct);
  const correctChoices=correctEntries.map(([,choice])=>choice);
  if(!correctChoices.length){
    choiceButtons.forEach(b=>{ b.disabled=true; b.classList.remove("selected"); });
    $("explain").hidden=false;
    $("explain").innerHTML="‚ö†Ô∏è Aucune bonne r√©ponse n‚Äôest d√©finie pour cette question. Pr√©venez l‚Äô√©quipe p√©dagogique afin de corriger le fichier.";
    if(currentQ && currentQ.id){ remember(currentQ.id); }
    $("nextBtn").disabled=false;
    updateCheckButton();
    return;
  }
  qCount++;
  const correctIds=new Set(correctEntries.map(([id])=>String(id)));
  const win = normalizedSelected.size===correctIds.size && [...normalizedSelected].every(id=>correctIds.has(id));
  if(win){
    goodCount++;
    streak++;
  }else{
    streak=0;
  }
  const effectiveLevel=normalizeLevel(currentQ.level);

  choiceButtons.forEach(btn=>{
    const id=btn.dataset.id;
    const isCorrect=correctIds.has(id);
    const picked=normalizedSelected.has(id);
    btn.disabled=true;
    btn.classList.remove("selected");
    if(isCorrect){
      btn.classList.add("answer","ok");
    }
    if(picked && !isCorrect){
      btn.classList.add("answer","ko");
    }
    if(picked && isCorrect){
      btn.classList.add("answer","ok");
    }
  });

  if(activeQuizMode==="normal"){ applyProgress(win); }
  const explanationText=currentQ.explanation?`<br>üí° ${currentQ.explanation}`:"";
  $("explain").hidden=false;
  $("explain").innerHTML=(win?"‚úÖ Correct.":"‚ùå Incorrect.")+explanationText;
  updateMeta();
  if(activeQuizMode==="revision"){
    const pickedText=[...normalizedSelected].map(id=>{
      const choice=choiceById.get(id);
      return choice && choice.text ? choice.text : "";
    }).filter(Boolean).join(" ¬∑ ") || "‚Äî";
    const correctText=correctChoices.map(c=>c && c.text ? c.text : "").filter(Boolean).join(" ¬∑ ") || "‚Äî";
    revisionHistory.push({
      id: currentQ.id,
      prompt: currentQ.prompt,
      picked: pickedText,
      correct: correctText,
      explanation: currentQ.explanation || "",
      win,
    });
    updateHistoryUI();
  }
  remember(currentQ.id);
  $("nextBtn").disabled=false;
  selectedChoiceIds.clear();
  updateCheckButton();
}
function renderQuestion(){
  if(!QUESTIONS || !QUESTIONS.length){
    $("qPrompt").textContent="Pas de questions (data/questions_normal.json)";
    $("choices").innerHTML=""; $("explain").hidden=true; $("nextBtn").disabled=true;
    const checkBtn=$("checkBtn");
    if(checkBtn){ checkBtn.hidden=true; checkBtn.disabled=true; }
    return;
  }
  currentQ = pickQuestion();
  if(!currentQ){
    $("qPrompt").textContent="Aucune question disponible pour ce niveau.";
    $("choices").innerHTML="";
    $("explain").hidden=false;
    $("explain").textContent="Ajoute davantage de questions dans la banque pour continuer.";
    $("nextBtn").disabled=true;
    const checkBtn=$("checkBtn");
    if(checkBtn){ checkBtn.hidden=true; checkBtn.disabled=true; }
    return;
  }
  locked=false;
  selectedChoiceIds.clear();
  choiceButtons=[];
  choiceById=new Map();

  let choices = filteredChoicesForLevel(currentQ.choices||[]);
  if(!choices.some(c=>c && c.correct) && (currentQ.choices||[]).some(c=>c && c.correct)){
    const correct = (currentQ.choices||[]).find(c=>c && c.correct);
    if(correct){
      choices = [correct, ...choices.filter(c=>!c || c.id!==correct.id)];
    }
  }
  const correctCount = (currentQ.choices||[]).filter(c=>c && c.correct).length;
  multiSelect = correctCount !== 1;

  $("qPrompt").textContent=currentQ.prompt;
  const container=$("choices");
  container.innerHTML="";
  choices.forEach((c, idx)=>{
    const b=document.createElement("button");
    b.className="choice";
    b.textContent=c && c.text ? c.text : `Option ${idx+1}`;
    const choiceId=(c && c.id!==undefined && c.id!==null) ? String(c.id) : String(idx);
    b.dataset.id=choiceId;
    choiceById.set(choiceId, c);
    b.onclick=()=>handleChoiceClick(choiceId, b);
    container.appendChild(b);
    choiceButtons.push(b);
  });
  $("explain").hidden=true; $("nextBtn").disabled=true;
  const checkBtn=$("checkBtn");
  if(checkBtn){
    checkBtn.onclick = () => {
      if(locked) return;
      if(!selectedChoiceIds.size) return;
      evaluateAnswer(new Set(selectedChoiceIds));
    };
  }
  updateCheckButton();
}
$("nextBtn").onclick=renderQuestion;

function resetQuizState(){
  elo=ELO_START;
  level=levelFromElo(elo);
  qCount=0;
  goodCount=0;
  streak=0;
  answeredTotal=0;
  recentIds.length=0;
  selectedChoiceIds.clear();
  choiceButtons=[];
  choiceById=new Map();
  multiSelect=false;
  const checkBtn=$("checkBtn");
  if(checkBtn){ checkBtn.hidden=true; checkBtn.disabled=true; }
}

/* ====== Bouton Elo ====== */
$("setEloBtn").onclick = () => {
  alert("‚ö†Ô∏è Attention : n'utilise pas ce r√©glage pour tricher ! üêÆ");
  const v = prompt("Entre ton Elo souhait√© (ex: 0). Conseill√©: 0‚Äì200");
  if(v===null) return;
  const n = Math.round(Number(v));
  if(Number.isNaN(n)) { alert("Valeur invalide."); return; }
  const maxLevel = availableLevels.length ? availableLevels[availableLevels.length-1] : 1;
  const maxElo = maxLevel * ELO_PER_LEVEL;
  const clamped = Math.max(ELO_START, Math.min(maxElo, n));
  elo = clamped;
  level = levelFromElo(elo);
  updateMeta();
};

/* ========= MODE R√âVISION (S5..S9) ========= */
const selSem = $("selSem"), ueCore=$("ueCore"), ueOpt=$("ueOpt");
function label(id,lbl){ return `<label class="pill"><input type="checkbox" data-id="${id}"> ${lbl}</label>`; }
function updateRevLaunchState(){
  $("revLaunch").disabled = !document.querySelector("#revision input:checked");
}
function subjectType(subject){
  if(!subject || typeof subject!=="object") return "core";
  if(subject.optional===true) return "option";
  if(typeof subject.core==="boolean") return subject.core?"core":"option";
  const raw = String(subject.type || subject.category || subject.group || subject.kind || "").toLowerCase();
  if(["core","tronc","mandatory","obligatoire"].includes(raw)) return "core";
  if(["option","opt","optional"].includes(raw)) return "option";
  return "core";
}
function findSemesterEntry(sem){
  return (REV_DATA.semesters||[]).find(entry=>{
    if(!entry) return false;
    const keys=[entry.sem, entry.id, entry.code, entry.semester].filter(Boolean);
    return keys.includes(sem);
  }) || null;
}
function sanitizeSubjects(list, entry){
  let source = Array.isArray(list) ? list : null;
  if(!source && entry){
    const fallback=[];
    if(Array.isArray(entry.core)) fallback.push(...entry.core.map(s=>{
      const copy = {...s};
      copy.type = (s && typeof s.type !== "undefined") ? s.type : "core";
      return copy;
    }));
    if(Array.isArray(entry.options)) fallback.push(...entry.options.map(s=>{
      const copy = {...s};
      copy.type = (s && typeof s.type !== "undefined") ? s.type : "option";
      return copy;
    }));
    if(fallback.length) source=fallback;
  }
  if(!Array.isArray(source)) return [];
  return source.filter(s=>s && s.id).map(s=>({
    id: s.id,
    label: s.label || s.name || s.id,
    type: subjectType(s),
    questions: Array.isArray(s.questions)?s.questions:[],
  }));
}
function fillUEsForSem(sem){
  const entry = findSemesterEntry(sem);
  const subjects = sanitizeSubjects(entry && entry.subjects, entry);
  const core = subjects.filter(s=>s.type!=="option");
  const opt = subjects.filter(s=>s.type==="option");
  ueCore.innerHTML = core.length ? core.map(u=>label(u.id,u.label)).join("") : "<span class=\"muted\">Aucun √©l√©ment</span>";
  ueOpt.innerHTML = opt.length ? opt.map(u=>label(u.id,u.label)).join("") : "<span class=\"muted\">Aucun √©l√©ment</span>";
  $("revLaunch").disabled=true;
  document.querySelectorAll("#revision input[type=checkbox]").forEach(i=>{
    i.onchange=updateRevLaunchState;
  });
}
selSem.onchange = () => fillUEsForSem(selSem.value);
$("btnAllCore").onclick=()=>{ const inputs=ueCore.querySelectorAll("input"); inputs.forEach(i=>i.checked=true); updateRevLaunchState(); };
$("btnAllOpt").onclick=()=>{ const inputs=ueOpt.querySelectorAll("input"); inputs.forEach(i=>i.checked=true); updateRevLaunchState(); };
$("btnClear").onclick=()=>{ document.querySelectorAll("#revision input[type=checkbox]").forEach(i=>i.checked=false); updateRevLaunchState(); };

function collectRevisionQuestions(ids){
  const out=[];
  if(!ids.size) return out;
  for(const sem of REV_DATA.semesters||[]){
    const subjects = sanitizeSubjects(sem && sem.subjects, sem);
    for(const subject of subjects){
      if(!subject || !ids.has(subject.id)) continue;
      const questions = Array.isArray(subject.questions)?subject.questions:[];
      questions.forEach((q,idx)=>{
        if(!q) return;
        const choices = Array.isArray(q.choices) ? q.choices.map(choice=>({...choice})) : [];
        out.push({
          id: q.id || `${subject.id}_${idx}`,
          level: (q.level !== undefined && q.level !== null) ? q.level : 1,
          prompt: q.prompt || "Question",
          choices,
          explanation: q.explanation || "",
        });
      });
    }
  }
  return out;
}

function listProfSubjects(){
  const seen=new Map();
  for(const sem of REV_DATA.semesters||[]){
    const subjects = sanitizeSubjects(sem && sem.subjects, sem);
    subjects.forEach(subject=>{
      if(subject && subject.id && !seen.has(subject.id)){
        seen.set(subject.id,{id:subject.id,label:subject.label||subject.id});
      }
    });
  }
  return [...seen.values()].sort((a,b)=>a.label.localeCompare(b.label,'fr',{sensitivity:'base'}));
}

$("revLaunch").onclick=()=>{
  const pickedIds = new Set([...document.querySelectorAll("#revision input:checked")].map(i=>i.dataset.id).filter(Boolean));
  if(!pickedIds.size) return;
  const selectedQuestions = collectRevisionQuestions(pickedIds);
  if(!selectedQuestions.length){
    alert("Aucune question trouv√©e pour les mati√®res s√©lectionn√©es.");
    return;
  }
  QUESTIONS = selectedQuestions.map(q=>({
    id: q.id,
    level: q.level,
    prompt: q.prompt,
    choices: Array.isArray(q.choices)?q.choices.map(c=>({...c})) : [],
    explanation: q.explanation,
  }));
  activeQuizMode="revision";
  resetQuizState();
  resetRevisionHistory();
  go("normal"); updateMeta(); renderQuestion();
};

/* ========= Outil prof ========= */
const profMatter=$("profMatter"), profPrompt=$("profPrompt"), profExplain=$("profExplain"), profOutput=$("profOutput");
const profChoicesWrap=$("profChoices");
const profChoiceAdd=$("profChoiceAdd");
const profChoiceRemove=$("profChoiceRemove");
const MIN_PROF_CHOICES=2;
const MAX_PROF_CHOICES=5;
let profChoiceItems=[];
let profCounter=1;

function profChoiceLabel(idx){
  return String.fromCharCode(65 + idx);
}

function updateProfChoiceButtons(){
  if(profChoiceAdd) profChoiceAdd.disabled = profChoiceItems.length>=MAX_PROF_CHOICES;
  if(profChoiceRemove) profChoiceRemove.disabled = profChoiceItems.length<=MIN_PROF_CHOICES;
}

function rebuildProfChoicePlaceholders(){
  profChoiceItems.forEach((item, idx)=>{
    if(item.input) item.input.placeholder = `R√©ponse ${profChoiceLabel(idx)}`;
  });
}

function addProfChoice(){
  if(!profChoicesWrap) return;
  if(profChoiceItems.length>=MAX_PROF_CHOICES) return;
  const label=document.createElement("label");
  const checkbox=document.createElement("input");
  checkbox.type="checkbox";
  const input=document.createElement("input");
  input.type="text";
  label.appendChild(checkbox);
  label.appendChild(input);
  profChoicesWrap.appendChild(label);
  profChoiceItems.push({label, checkbox, input});
  rebuildProfChoicePlaceholders();
  updateProfChoiceButtons();
  input.focus();
}

function removeProfChoice(){
  if(!profChoicesWrap) return;
  if(profChoiceItems.length<=MIN_PROF_CHOICES) return;
  const item=profChoiceItems.pop();
  if(item && item.label && item.label.parentNode===profChoicesWrap){
    profChoicesWrap.removeChild(item.label);
  }
  rebuildProfChoicePlaceholders();
  updateProfChoiceButtons();
}

function fillProfMatter(){
  if(!profMatter) return;
  const current=profMatter.value;
  const list=listProfSubjects();
  if(!list.length){
    profMatter.innerHTML = '<option value="">Aucune mati√®re disponible</option>';
    profMatter.value="";
    return;
  }
  profMatter.innerHTML = list.map(item=>`<option value="${item.id}">${item.label}</option>`).join("");
  profMatter.value = list.some(item=>item.id===current) ? current : list[0].id;
}
fillProfMatter();

function initProfChoices(){
  if(!profChoicesWrap) return;
  profChoicesWrap.innerHTML="";
  profChoiceItems=[];
  const initialChoices=4;
  for(let i=0;i<initialChoices;i++) addProfChoice();
  updateProfChoiceButtons();
}
initProfChoices();
if(profChoiceAdd) profChoiceAdd.onclick=()=>{ addProfChoice(); };
if(profChoiceRemove) profChoiceRemove.onclick=()=>{ removeProfChoice(); };

function resetProfFields(){
  profPrompt.value="";
  profExplain.value="";
  profChoiceItems.forEach(item=>{
    if(item.input) item.input.value="";
    if(item.checkbox) item.checkbox.checked=false;
  });
}

function addRevisionQuestion(){
  const matter=profMatter.value;
  const prompt=profPrompt.value.trim();
  const explanation=profExplain.value.trim();
  const answers=profChoiceItems.map(item=>item && item.input ? item.input.value.trim() : "");
  const correctSelections=profChoiceItems.filter(item=>item && item.checkbox && item.checkbox.checked);

  if(!matter){ alert("Choisissez une mati√®re."); return; }
  if(!prompt){ alert("Ajoutez un √©nonc√©."); profPrompt.focus(); return; }
  if(answers.some(a=>!a)){ alert("Toutes les r√©ponses doivent √™tre renseign√©es."); return; }
  if(!correctSelections.length){ alert("S√©lectionnez au moins une r√©ponse correcte."); return; }

  const idBase=matter.replace(/[^a-z0-9_]+/gi,"_");
  const questionId=`${idBase}_${Date.now().toString(36)}_${profCounter++}`;
  const choices=answers.map((text,idx)=>{
    const choice={id:`${idBase}_c${idx+1}`,text};
    const item=profChoiceItems[idx];
    if(item && item.checkbox && item.checkbox.checked) choice.correct=true;
    return choice;
  });
  const payload={id:questionId,level:5,prompt,choices,explanation:explanation||""};
  const line=JSON.stringify(payload);
  profOutput.value = profOutput.value ? `${profOutput.value}\n${line}` : line;
  profOutput.scrollTop = profOutput.scrollHeight;
  resetProfFields();
  profPrompt.focus();
}

$("profAdd").onclick=addRevisionQuestion;
$("profReset").onclick=()=>{ resetProfFields(); profOutput.value=""; };

/* ========= P√âDANTIX (daily) ‚Äî lemmatisation FR renforc√©e ========= */
const wordRe = /[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø'-]+|[^A-Za-z√Ä-√ñ√ò-√∂√∏-√ø'-]+/g;
let pedState = {
  date: null,
  target: null,
  text: "",
  tokens: [],
  revealed: new Set(),
  targetKeys: new Set(),
  titleTokens: [],
  titleLetters: 0,
  won: false,
};

/* irr√©guliers + participes pr√©sents fr√©quents (sans accents car strip) */
const IRREG_FORMS = {
  "etre":"etre",
  "faire":"faire",
  "dire":"dire",
  /* AVOIR */
  "ai":"avoir","as":"avoir","a":"avoir","avons":"avoir","avez":"avoir","ont":"avoir",
  "avais":"avoir","avait":"avoir","avions":"avoir","aviez":"avoir","avaient":"avoir",
  "aurai":"avoir","auras":"avoir","aura":"avoir","aurons":"avoir","aurez":"avoir","auront":"avoir",
  "aurais":"avoir","aurait":"avoir","aurions":"avoir","auriez":"avoir","auraient":"avoir",
  "eu":"avoir","eue":"avoir","eus":"avoir","eut":"avoir","eues":"avoir","eumes":"avoir","eutes":"avoir","eurent":"avoir",
  "ayant":"avoir",
  /* ETRE */
  "suis":"etre","es":"etre","est":"etre","sommes":"etre","etes":"etre","sont":"etre",
  "etais":"etre","etait":"etre","etions":"etre","etiez":"etre","etaient":"etre",
  "serai":"etre","seras":"etre","sera":"etre","serons":"etre","serez":"etre","seront":"etre",
  "serais":"etre","serait":"etre","serions":"etre","seriez":"etre","seraient":"etre",
  "ete":"etre","etant":"etre",
  /* ALLER */
  "vais":"aller","vas":"aller","va":"aller","allons":"aller","allez":"aller","vont":"aller",
  "allais":"aller","allait":"aller","allions":"aller","alliez":"aller","allaient":"aller",
  "irai":"aller","iras":"aller","ira":"aller","irons":"aller","irez":"aller","iront":"aller",
  "irais":"aller","irait":"aller","irions":"aller","iriez":"aller","iraient":"aller",
  "allant":"aller",
  /* FAIRE */
  "fais":"faire","fait":"faire","faisons":"faire","faites":"faire","font":"faire",
  "faisais":"faire","faisait":"faire","faisions":"faire","faisiez":"faire","faisaient":"faire",
  "ferai":"faire","feras":"faire","fera":"faire","ferons":"faire","ferez":"faire","feront":"faire",
  "ferais":"faire","ferait":"faire","ferions":"faire","feriez":"faire","feraient":"faire",
  "faisant":"faire",
  /* POUVOIR */
  "peux":"pouvoir","peut":"pouvoir","pouvons":"pouvoir","pouvez":"pouvoir","peuvent":"pouvoir",
  "pouvais":"pouvoir","pouvait":"pouvoir","pouvions":"pouvoir","pouvez":"pouvoir","pouvaient":"pouvoir",
  "pourrai":"pouvoir","pourras":"pouvoir","pourra":"pouvoir","pourrons":"pouvoir","pourrez":"pouvoir","pourront":"pouvoir",
  "pourrais":"pouvoir","pourrait":"pouvoir","pourrions":"pouvoir","pourriez":"pouvoir","pourraient":"pouvoir",
  "pu":"pouvoir","pue":"pouvoir","pus":"pouvoir","put":"pouvoir","purent":"pouvoir",
  "pouvant":"pouvoir",
  /* DEVOIR */
  "dois":"devoir","doit":"devoir","devons":"devoir","devez":"devoir","doivent":"devoir",
  "devais":"devoir","devait":"devoir","devions":"devoir","deviez":"devoir","devaient":"devoir",
  "devrai":"devoir","devras":"devoir","devra":"devoir","devrons":"devoir","devrez":"devoir","devront":"devoir",
  "devrais":"devoir","devrait":"devoir","devrions":"devoir","devriez":"devoir","devraient":"devoir",
  "du":"devoir","due":"devoir","dus":"devoir","dut":"devoir","durent":"devoir",
  "devant":"devoir",
  /* SAVOIR */
  "sais":"savoir","sait":"savoir","savons":"savoir","savez":"savoir","savent":"savoir",
  "savais":"savoir","savait":"savoir","savions":"savoir","saviez":"savoir","savaient":"savoir",
  "saurai":"savoir","sauras":"savoir","saura":"savoir","saurons":"savoir","saurez":"savoir","sauront":"savoir",
  "saurais":"savoir","saurait":"savoir","saurions":"savoir","sauriez":"savoir","sauraient":"savoir",
  "su":"savoir","sachant":"savoir",
  /* VENIR */
  "viens":"venir","vient":"venir","venons":"venir","venez":"venir","viennent":"venir",
  "venais":"venir","venait":"venir","venions":"venir","veniez":"venir","venaient":"venir",
  "viendrai":"venir","viendras":"venir","viendra":"venir","viendrons":"venir","viendrez":"venir","viendront":"venir",
  "viendrais":"venir","viendrait":"venir","viendrions":"venir","viendriez":"venir","viendraient":"venir",
  "venu":"venir","venant":"venir",
  /* VOULOIR */
  "veux":"vouloir","veut":"vouloir","voulons":"vouloir","voulez":"vouloir","veulent":"vouloir",
  "voulais":"vouloir","voulait":"vouloir","voulions":"vouloir","vouliez":"vouloir","voulaient":"vouloir",
  "voudrai":"vouloir","voudras":"vouloir","voudra":"vouloir","voudrons":"vouloir","voudrez":"vouloir","voudront":"vouloir",
  "voudrais":"vouloir","voudrait":"vouloir","voudrions":"vouloir","voudriez":"vouloir","voudraient":"vouloir",
  "voulu":"vouloir","voulant":"vouloir",
  /* DIRE */
  "dis":"dire","dit":"dire","disons":"dire","dites":"dire","disent":"dire",
  "disais":"dire","disait":"dire","disions":"dire","disiez":"dire","disaient":"dire",
  "dirai":"dire","diras":"dire","dira":"dire","dirons":"dire","direz":"dire","diront":"dire",
  "dirais":"dire","dirait":"dire","dirions":"dire","diriez":"dire","diraient":"dire",
  "disant":"dire",
  /* METTRE */
  "mets":"mettre","met":"mettre","mettons":"mettre","mettez":"mettre","mettent":"mettre",
  "mettais":"mettre","mettait":"mettre","mettions":"mettre","mettiez":"mettre","mettaient":"mettre",
  "mettrai":"mettre","mettras":"mettre","mettra":"mettre","mettrons":"mettre","mettrez":"mettre","mettront":"mettre",
  "mettrais":"mettre","mettrait":"mettre","mettrions":"mettre","mettriez":"mettre","mettraient":"mettre",
  "mis":"mettre","mettant":"mettre",
  /* PRENDRE */
  "prends":"prendre","prend":"prendre","prenons":"prendre","prenez":"prendre","prennent":"prendre",
  "prenais":"prendre","prenait":"prendre","prenions":"prendre","preniez":"prendre","prenaient":"prendre",
  "prendrai":"prendre","prendras":"prendre","prendra":"prendre","prendrons":"prendre","prendrez":"prendre","prendront":"prendre",
  "prendrais":"prendre","prendrait":"prendre","prendrions":"prendre","prendriez":"prendre","prendraient":"prendre",
  "pris":"prendre","prenant":"prendre",
  /* VOIR */
  "vois":"voir","voit":"voir","voyons":"voir","voyez":"voir","voient":"voir",
  "voyais":"voir","voyait":"voir","voyions":"voir","voyiez":"voir","voyaient":"voir",
  "verrai":"voir","verras":"voir","verra":"voir","verrons":"voir","verrez":"voir","verront":"voir",
  "verrais":"voir","verrait":"voir","verrions":"voir","verriez":"voir","verraient":"voir",
  "vu":"voir","voyant":"voir",
  /* TENIR */
  "tiens":"tenir","tient":"tenir","tenons":"tenir","tenez":"tenir","tiennent":"tenir",
  "tenais":"tenir","tenait":"tenir","tenions":"tenir","teniez":"tenir","tenaient":"tenir",
  "tiendrai":"tenir","tiendras":"tenir","tiendra":"tenir","tiendrons":"tenir","tiendrez":"tenir","tiendront":"tenir",
  "tiendrais":"tenir","tiendrait":"tenir","tiendrions":"tenir","tiendriez":"tenir","tiendraient":"tenir",
  "tenu":"tenir","tenant":"tenir",
  /* PARTIR/SORTIR */
  "pars":"partir","part":"partir","partons":"partir","partez":"partir","partent":"partir","partant":"partir",
  "sorts":"sortir","sort":"sortir","sortons":"sortir","sortez":"sortir","sortent":"sortir","sortant":"sortir",
  /* BOIRE */
  "bois":"boire","boit":"boire","buvons":"boire","buvez":"boire","boivent":"boire",
  "buvais":"boire","buvait":"boire","buvions":"boire","buviez":"boire","buvaient":"boire",
  "boirai":"boire","boiras":"boire","boira":"boire","boirons":"boire","boirez":"boire","boiront":"boire",
  "bu":"boire","bus":"boire","but":"boire","burent":"boire","buvant":"boire",
  /* LIRE */
  "lis":"lire","lit":"lire","lisons":"lire","lisez":"lire","lisent":"lire","lisant":"lire",
  /* ECRIRE */
  "ecris":"ecrire","ecrit":"ecrire","ecrivons":"ecrire","ecrivez":"ecrire","ecrivent":"ecrire","ecrivant":"ecrire",
  /* CONNAITRE */
  "connais":"connaitre","connait":"connaitre","connaissons":"connaitre","connaissez":"connaitre","connaissent":"connaitre","connaissant":"connaitre",
  /* CROIRE */
  "crois":"croire","croit":"croire","croyons":"croire","croyez":"croire","croient":"croire","croyant":"croire",
  /* VIVRE */
  "vis":"vivre","vit":"vivre","vivons":"vivre","vivez":"vivre","vivent":"vivre","vivant":"vivre",
  /* OUVRIR/OFFRIR */
  "ouvre":"ouvrir","ouvres":"ouvrir","ouvrons":"ouvrir","ouvrez":"ouvrir","ouvrent":"ouvrir","ouvrant":"ouvrir",
  "offre":"offrir","offres":"offrir","offrons":"offrir","offrez":"offrir","offrent":"offrir","offrant":"offrir",
  /* COURIR */
  "cours":"courir","court":"courir","courons":"courir","courez":"courir","courent":"courir","courant":"courir",
  /* RIRE/SOURIRE */
  "ris":"rire","rit":"rire","rions":"rire","riez":"rire","rient":"rire","ri":"rire","riant":"rire",
  "souris":"sourire","sourit":"sourire","sourions":"sourire","souriez":"sourire","sourient":"sourire","souri":"sourire","souriant":"sourire",
  /* ENVOYER/RECEVOIR/VALOIR/PLEUVOIR */
  "envoie":"envoyer","envoies":"envoyer","envoyons":"envoyer","envoyez":"envoyer","envoient":"envoyer","envoyant":"envoyer",
  "recois":"recevoir","recoit":"recevoir","recevons":"recevoir","recevez":"recevoir","recoivent":"recevoir","recevant":"recevoir",
  "vaux":"valoir","vaut":"valoir","valons":"valoir","valez":"valoir","valent":"valoir","valu":"valoir","valant":"valoir",
  "pleut":"pleuvoir","pleuvait":"pleuvoir","pleuvra":"pleuvoir","plu":"pleuvoir","pleuvant":"pleuvoir"
};

function lemmaFr(rawWord){
  // retire √©lisions communes et normalise
  const cleaned = (rawWord || "").replace(/^([ldmtscnj])'|^qu'|^jusqu'|^lorsqu'|^puisqu'/i, "");
  let w = strip(cleaned);
  if (!w) return w;
  if (IRREG_FORMS[w]) return IRREG_FORMS[w];
  if(/\s/.test(cleaned)) return w;

  // R√àGLES PRIORITAIRES ‚Äî participes/adjectifs
  // 1er groupe: montant/montante/montants/montantes -> monter
  if (/(ant|ante|ants|antes)$/.test(w)) {
    const stem = w.replace(/(ant|ante|ants|antes)$/, "er");
    if (stem.length>=3) return stem;
  }
  // 2e groupe: finissant/finissante/... -> finir
  if (/(issant|issante|issants|issantes)$/.test(w)) {
    const stem = w.replace(/(issant|issante|issants|issantes)$/, "ir");
    if (stem.length>=3) return stem;
  }

  const rawLower = cleaned.toLowerCase();
  const rawNFD = cleaned.normalize("NFD");
  const hasAcute = /\u0301/.test(rawNFD) || rawLower.includes("√©");

  // Heuristiques verbales ‚Äî ordre important
  const rules = [
    // participes/g√©rondifs 1er groupe (uniquement si accent dans la forme originale)
    [/(ees|ee|es|e)$/i, v => hasAcute ? v.replace(/(ees|ee|es|e)$/i, "er") : v],
    [/ant$/i, v => v.replace(/ant$/i, "er")],
    // participes/g√©rondifs 2e groupe
    [/(ies|ie|is|it)$/i, v => /(ais|ait)$/i.test(v) ? v : v.replace(/(ies|ie|is|it)$/i, "ir")],
    [/(ues)$/i, v => v.replace(/ues$/i, "u")],
    [/(ue)$/i, v => v.replace(/ue$/i, "u")],
    [/(us)$/i, v => v.replace(/us$/i, "u")],
    [/(u)$/i, v => v],
    // imparfait
    [/(ais|ait|ions|iez|aient)$/i, v => v.replace(/(ais|ait|ions|iez|aient)$/i, "")],
    // futur/conditionnel 1er groupe
    [/(erai|eras|era|erons|erez|eront)$/i, v => v.replace(/(erai|eras|era|erons|erez|eront)$/i, "er")],
    [/(erais|erait|erions|eriez|eraient)$/i, v => v.replace(/(erais|erait|erions|eriez|eraient)$/i, "er")],
    // pr√©sent 1er groupe
    [/(e|es|ons|ez|ent)$/i, v => /(euses?|trices?|ives?|elles?|ennes?|onnes?|ettes?)$/i.test(v) ? v : v.replace(/(e|es|ons|ez|ent)$/i, "er")],
    // 2e groupe -ir
    [/(irai|iras|ira|irons|irez|iront)$/i, v => v.replace(/(irai|iras|ira|irons|irez|iront)$/i, "ir")],
    [/(irais|irait|irions|iriez|iraient)$/i, v => v.replace(/(irais|irait|irions|iriez|iraient)$/i, "ir")],
    [/(issons|issez|issent)$/i, v => v.replace(/(issons|issez|issent)$/i, "ir")],
    [/(is|it)$/i, v => v.replace(/(is|it)$/i, "ir")],
    // 3e groupe divers
    [/re$/i, v => v]
  ];
  let lemma = w;
  for(const [re, transform] of rules){
    if(re.test(lemma)){
      const stem = transform(lemma);
      if(stem && stem.length>=3 && stem!==lemma){
        lemma = IRREG_FORMS[stem] || stem;
      }
    }
  }
  return lemma;
}

function expandGenderNumber(base, acc){
  if(!base || base.length<3) return;
  if(/\s/.test(base)) return;
  const rules = [
    [/euses?$/i, val => val.replace(/euses?$/i, "eux")],
    [/trices?$/i, val => val.replace(/trices?$/i, "teur")],
    [/rices?$/i, val => val.replace(/rices?$/i, "eur")],
    [/ives?$/i, val => val.replace(/ives?$/i, "if")],
    [/ales?$/i, val => val.replace(/ales?$/i, "al")],
    [/elles?$/i, val => val.replace(/elles?$/i, "el")],
    [/ennes?$/i, val => val.replace(/ennes?$/i, "en")],
    [/onnes?$/i, val => val.replace(/onnes?$/i, "on")],
    [/eaux$/i, val => val.replace(/eaux$/i, "eau")],
    [/aux$/i, val => val.replace(/aux$/i, "al")],
    [/ettes?$/i, val => val.replace(/ettes?$/i, "et")]
  ];
  for(const [re, fn] of rules){
    if(re.test(base)){
      const v = fn(base);
      if(v && v.length>=3) acc.add(v);
    }
  }
  if(base.endsWith("es") && base.length>4) acc.add(base.slice(0,-2));
  if(base.endsWith("s") && base.length>3) acc.add(base.slice(0,-1));
  if(base.endsWith("x") && base.length>3) acc.add(base.slice(0,-1));
}

function buildKeySet(norm, lemma, raw){
  const set = new Set();
  const add = v => { if(v && v.length) set.add(v); };
  add(norm);
  add(lemma);
  if(raw && raw!==norm){ add(strip(raw)); }
  [norm, lemma].forEach(b=>expandGenderNumber(b, set));
  return set;
}

function hasIntersection(setA, setB){
  if(!setA || !setB) return false;
  for(const v of setA){ if(setB.has(v)) return true; }
  return false;
}

function tokenize(text){
  const parts = text.match(wordRe) || [];
  return parts.map(p=>{
    const isWord = /[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø'-]+/.test(p);
    const norm = isWord ? strip(p) : p;
    const lemma = isWord ? lemmaFr(p) : p;
    const keys = isWord ? buildKeySet(norm, lemma, p) : new Set();
    return { raw:p, norm, lemma, isWord, keys };
  });
}
function tokenizeTitle(title){
  const parts = (title || "").match(wordRe) || [];
  return parts.map(part=>{
    const isWord = /[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø'-]+/.test(part);
    if(!isWord){
      return { raw: part, isWord: false };
    }
    const norm = strip(part);
    const lemma = lemmaFr(part);
    const keys = buildKeySet(norm, lemma, part);
    const chars = [...part];
    const letters = chars.filter(ch=>/[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]/.test(ch)).length || part.length;
    const mask = chars.map(ch=>/[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]/.test(ch) ? "‚ñà" : ch).join("");
    return { raw: part, isWord: true, keys, revealed: false, letters, mask };
  });
}
function titleMask(){
  if(pedState.titleTokens && pedState.titleTokens.length){
    const total = pedState.titleLetters || pedState.titleTokens.reduce((acc, token)=>{
      return acc + (token.isWord ? (token.letters || 0) : 0);
    }, 0);
    const display = pedState.titleTokens.map(token=>{
      if(!token.isWord) return token.raw;
      return (pedState.won || token.revealed) ? token.raw : token.mask;
    }).join("");
    const label = total === 1 ? "lettre" : "lettres";
    return `Titre : ${display} (${total} ${label})`;
  }
  if(!pedState.target) return "";
  const letters = [...pedState.target];
  const masked = letters.map(ch=>{
    if(/\s/.test(ch)) return " ";
    if(/[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]/.test(ch)) return "‚ñà";
    return ch;
  }).join("");
  const total = letters.filter(c=>/[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]/.test(c)).length;
  const label = total === 1 ? "lettre" : "lettres";
  return `Titre : ${masked} (${total} ${label})`;
}
function renderPed(){
  $("pedTitleMask").textContent = titleMask();
  const frag = document.createDocumentFragment();
  const makeMask = (token)=>{
    const mask = document.createElement("span");
    mask.className="mask";
    const masked = "‚ñà".repeat(Math.max(1, token.raw.length));
    const letterCount = (token.raw.match(/[A-Za-z√Ä-√ñ√ò-√∂√∏-√ø]/g) || []).length || token.raw.length;
    mask.textContent = masked;
    mask.dataset.mask = masked;
    mask.dataset.letters = String(letterCount);
    mask.tabIndex = 0;
    const baseLabel = `Mot cach√© de ${letterCount} lettre${letterCount>1?'s':''}`;
    mask.setAttribute("aria-label", baseLabel);
    const showLen = ()=>{
      mask.textContent = `${letterCount} lettre${letterCount>1?'s':''}`;
      mask.classList.add("mask-show");
    };
    const hideLen = ()=>{
      mask.textContent = mask.dataset.mask || masked;
      mask.classList.remove("mask-show");
    };
    mask.addEventListener("mousedown", evt=>{ evt.preventDefault(); showLen(); });
    mask.addEventListener("mouseup", hideLen);
    mask.addEventListener("mouseleave", hideLen);
    mask.addEventListener("touchstart", evt=>{ evt.preventDefault(); showLen(); });
    mask.addEventListener("touchend", hideLen);
    mask.addEventListener("touchcancel", hideLen);
    mask.addEventListener("blur", hideLen);
    mask.addEventListener("keydown", evt=>{
      if(evt.key===" " || evt.key==="Enter"){
        evt.preventDefault();
        showLen();
      }
    });
    mask.addEventListener("keyup", hideLen);
    mask.addEventListener("click", evt=>{ evt.preventDefault(); showLen(); setTimeout(hideLen, 200); });
    return mask;
  };
  pedState.tokens.forEach(t=>{
    const span = document.createElement("span");
    span.className = "token";
    if(!t.isWord){ span.textContent = t.raw; }
    else {
      const show = pedState.won || hasIntersection(t.keys, pedState.revealed);
      if(show){
        span.textContent = t.raw;
      } else {
        span.appendChild(makeMask(t));
      }
    }
    frag.appendChild(span);
  });
  const host=$("pedText"); host.innerHTML=""; host.appendChild(frag);
}
function pickDaily(){
  const entry = PED_DAILY;
  pedState.date = (entry && entry.date) || todayISO;
  pedState.target = (entry && entry.target) || "Chloroplaste";
  pedState.text = (entry && entry.text) || "Texte d√©mo.";
  pedState.tokens = tokenize(pedState.text);
  pedState.titleTokens = tokenizeTitle(pedState.target);
  pedState.titleLetters = pedState.titleTokens.reduce((acc, token)=>{
    return acc + (token.isWord ? (token.letters || 0) : 0);
  }, 0);
  pedState.revealed = new Set(); // tout masqu√©
  pedState.targetKeys = buildKeySet(strip(pedState.target), lemmaFr(pedState.target), pedState.target);
  pedState.won = false;
  $("pedGuesses").innerHTML="";
  $("pedScore").hidden=true;
  renderPed();
}
function guessWord(w){
  const gRaw = (w||"").trim(); if(!gRaw) return {hits:0,win:false};
  const gNorm = strip(gRaw);
  const gLemma = lemmaFr(gRaw);
  const guessKeys = buildKeySet(gNorm, gLemma, gRaw);
  const win = !!pedState.won || hasIntersection(guessKeys, pedState.targetKeys);
  let hits = 0;
  if(!win){
    for(const t of pedState.tokens){
      if(!t.isWord) continue;
      if(hasIntersection(t.keys, guessKeys)){
        hits++;
        t.keys.forEach(k=>pedState.revealed.add(k));
      }
    }
  } else {
    pedState.won = true;
    pedState.tokens.forEach(t=>{ if(t.isWord) t.keys.forEach(k=>pedState.revealed.add(k)); });
  }
  (pedState.titleTokens || []).forEach(token=>{
    if(!token.isWord) return;
    if(pedState.won || hasIntersection(token.keys, pedState.revealed) || hasIntersection(token.keys, guessKeys)){
      token.revealed = true;
    }
  });
  renderPed();
  return {hits,win};
}
$("pedInput").addEventListener("keydown",e=>{
  if(e.key!=="Enter") return;
  const val = $("pedInput").value.trim(); if(!val) return;
  const {hits,win} = guessWord(val);
  const li=document.createElement("li"); li.className="result-item";
  li.innerHTML=`<div class="num ${win?'ok':(hits>0?'ok':'ko')}">${$("pedGuesses").children.length+1}</div><div><b>${val}</b> ‚Äî ${win?'üéØ Titre trouv√© !':(hits>0?`${hits} occurrence(s)`:'0')}</div>`;
  $("pedGuesses").prepend(li);
  if(win){
    $("pedScore").hidden=false;
    $("pedScore").textContent="BRAVO !";
  }
  $("pedInput").value="";
});
$("pedReset").onclick=pickDaily;
const pedInfoBtn = $("pedInfo");
const pedInfoPanel = $("pedInfoPanel");
if(pedInfoBtn && pedInfoPanel){
  pedInfoBtn.addEventListener("click",()=>{
    const expanded = pedInfoBtn.getAttribute("aria-expanded") === "true";
    const next = !expanded;
    pedInfoBtn.setAttribute("aria-expanded", next ? "true" : "false");
    pedInfoPanel.hidden = !next;
  });
}
const historyBtnEl=$("historyBtn");
const historyCloseEl=$("historyClose");
const historyPanelEl=$("historyPanel");
if(historyBtnEl){
  historyBtnEl.addEventListener("click",()=>{
    updateHistoryUI();
    if(historyPanelEl) historyPanelEl.hidden=false;
  });
}
if(historyCloseEl){
  historyCloseEl.addEventListener("click",()=>{ if(historyPanelEl) historyPanelEl.hidden=true; });
}
if(historyPanelEl){
  historyPanelEl.addEventListener("click",evt=>{ if(evt.target===historyPanelEl) historyPanelEl.hidden=true; });
}

function ensureDataLoaded(){
  if(loaded) return Promise.resolve(true);
  return loadData().then(()=>true).catch(err=>{
    console.error("√âchec du chargement des donn√©es du quiz :", err);
    if(!QUESTIONS_NORMAL.length){
      QUESTIONS_NORMAL = cloneQuestionList(DEMO_QUESTIONS);
      QUESTIONS = [...QUESTIONS_NORMAL];
      prepareLevelBuckets(QUESTIONS_NORMAL);
    }
    normalDataFallback = true;
    if(!normalDataError){
      normalDataError = "Impossible de charger data/questions_normal.json. Jeu de d√©mo utilis√©.";
    }
    return false;
  });
}

function launchMode(mode){
  if(mode==="normal"){
    restoreNormalQuestions();
    go("normal");
    updateMeta();
    renderQuestion();
  } else if(mode==="revision"){
    go("revision");
    fillUEsForSem((selSem && selSem.value) || "S5");
  } else if(mode==="pedantix"){
    go("pedantix");
    pickDaily();
  } else if(mode==="prof"){
    go("prof");
    fillProfMatter();
    if(profPrompt) profPrompt.focus();
  }
}

/* ========= Handlers d‚Äôaccueil ========= */
document.querySelectorAll("[data-go]").forEach(b=>{
  b.addEventListener("click",()=>{
    const m=b.dataset.go || "home";
    ensureDataLoaded().then(()=>{
      launchMode(m);
    });
  });
});

/* ========= Boot ========= */
const urlMode = new URLSearchParams(location.search).get("mode") || "home";
(function boot(){
  if(urlMode==="home"){ go("home"); return; }
  ensureDataLoaded().then(()=>{
    if(urlMode==="normal"){
      launchMode("normal");
    } else if(urlMode==="revision"){
      launchMode("revision");
    } else if(urlMode==="pedantix"){
      launchMode("pedantix");
    } else if(urlMode==="prof"){
      launchMode("prof");
    } else {
      go("home");
    }
  });
})();
</script>
</body>
</html>
